{
  "filename": "implementation-of-rest-protocol-in-dubbo-go.md",
  "__html": "<h1><a href=\"https://mp.weixin.qq.com/s/9ngGYnkdcu14GkaPBjOBLg\">dubbo-go 中 REST 协议实现</a></h1>\n<p>在社区小伙伴们的努力下，Apache/dubbo-go 在 v1.4.0 中支持 REST 协议了。</p>\n<h2>什么是 REST 协议</h2>\n<p>REST 是  <strong>RE</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer（表述性状态转移）的简写，是一种软件架构风格。虽然 REST 架构风格不是一定要基于 HTTP 协议进行传输，但是因为 HTTP 协议的通用性和易用性，现在越来越多的 web 服务采用基于 HTTP 协议实现 RESTful 架构。</p>\n<p>在 dubbo-go 中的 REST 协议指的是一种基于 HTTP 协议的远程调用方式。简单的来讲，REST 协议就是把 dubbo 服务发布成 RESTful 风格的 HTTP 接口并且能够能像调用 dubbo 接口一样的方式调用 HTTP 接口。</p>\n<h2>为什么要支持 REST 协议</h2>\n<p>在没有 REST 协议之前，小伙伴们是否一直在苦恼这样几个问题：</p>\n<ol>\n<li>传统的 web 服务不能直接调用我们发布的 dubbo 服务</li>\n<li>前端不能直接调用 dubbo 服务</li>\n<li>dubbo 服务不能发布 Open API</li>\n</ol>\n<p>上述问题，就是 REST 协议解决的核心问题。现在我们很多应用场景都是需要与异构的系统进行交互，而 REST 采用的 HTTP 通信协议非常适合用来打通异构系统，如图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/webp/1001139/1585566216491-32cab604-7e00-412a-a79c-49d9c67d810f.webp#align=left&amp;display=inline&amp;height=430&amp;margin=%5Bobject%20Object%5D&amp;name=640.webp&amp;originHeight=430&amp;originWidth=532&amp;size=10938&amp;status=done&amp;style=none&amp;width=532\" alt=\"640.webp\"></p>\n<h2>REST 协议没那么简单</h2>\n<p>REST 协议核心要解决一个问题：<strong>Go 方法到 HTTP 接口的双向映射</strong>。普通 HTTP 调用 dubbo-go 服务，考虑的是 HTTP 到 <strong>Go</strong> 方法的映射；而 dubbo-go 服务调用 HTTP 服务，则是 <strong>Go</strong> 方法到 HTTP 接口的映射。</p>\n<p>下面是我们要与 <strong>Go</strong> 方法要做映射的 HTTP 请求协议内容：</p>\n<pre><code class=\"language-http\"><span class=\"hljs-keyword\">POST</span> <span class=\"hljs-string\">/path/{pathParam}?queryParam=1</span> HTTP/1.1\n<span class=\"hljs-attribute\">Accept</span>: application/json\n<span class=\"hljs-attribute\">Content-Type</span>: application/json\n<span class=\"hljs-attribute\">Host</span>: http://localhost:8080\n\n<span class=\"json\">{<span class=\"hljs-attr\">\"id\"</span>:<span class=\"hljs-number\">1111</span>}\n</span></code></pre>\n<p>在服务提供方，当上面这种请求发送到服务器时，我们要把它路由到下面这个 <strong>Go</strong> 方法中，在服务消费方，我们也可以通过调用下面的 <strong>Go</strong> 方法把方法参数转化为上面的 HTTP 请求：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> Provider <span class=\"hljs-keyword\">struct</span> {\n\n    <span class=\"hljs-comment\">// 该方法应该对应上面的http请求</span>\n    GetResult <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(pathParam <span class=\"hljs-keyword\">string</span>, queryParam <span class=\"hljs-keyword\">string</span>, body <span class=\"hljs-keyword\">interface</span>{}, host <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(*Result, error)</span></span>\n\n}\n</code></pre>\n<p>在消费方调用  <code>GetResult</code> 时，传入各个参数的值：</p>\n<ul>\n<li>变量  pathParam 的内容应该是字符串 &quot;pathParam&quot;；</li>\n<li>变量  queryParam 的内容应该是字符串  &quot;1&quot; ；</li>\n<li>变量  body 应该是有以字符串 &quot;id&quot; 为 key ，1111 为 value 的一个 map；</li>\n<li>当然  host 变量的内容应该是字符串 &quot;<a href=\"http://localhost:8080\">http://localhost:8080</a>&quot; 。</li>\n</ul>\n<p>在服务端执行 <code>GetResult</code> 方法时，得到的参数会与消费方调用时传入的值相同。</p>\n<p>总结下来，我们要建立以下这些映射关系</p>\n<ol>\n<li>路径映射</li>\n<li>Header 处理（固定 Header 和 Header 值也是参数两种情况）</li>\n<li>POST or GET or ...（HTTP  方法映射）</li>\n<li>参数映射</li>\n</ol>\n<p>要完成这种映射，我们首先要解决的是，如何知道这种映射关系？</p>\n<p>答案只有一个，通过用户配置。而用户配置所面临的困难是，复杂且琐碎。（解决思路是提供大量默认配置减轻配置的负担，自定义配置方式允许用户使用自己熟悉的配置形式）</p>\n<p>另外一个难点在于，使用何种 web 框架的问题。有些公司内部使用的是自研的 web 框架，他们有成熟的技术基础和运维能力。于是就会考虑说，能不能让 dubbo-go 在支持 REST 协议的时候，能够让他们将 REST 协议使用的 web 框架替换成他们所期望的呢？</p>\n<h2>如何建立 HTTP 接口与方法的映射关系</h2>\n<p>下面我举一个 HTTP 接口与方法映射的具体例子：</p>\n<p><strong>Go</strong> 结构体定义如下：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> UserProvider <span class=\"hljs-keyword\">struct</span> {\n\n    GetUser <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(id <span class=\"hljs-keyword\">string</span>, name <span class=\"hljs-keyword\">string</span>, age <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(*User, error)</span></span>\n\n}\n</code></pre>\n<p>要发布的 HTTP 接口形式是：\n<a href=\"http://127.0.0.1/UserProvider/GetUser/%7Bid%7D?name=test&amp;age=1\">http://127.0.0.1/UserProvider/GetUser/{id}?name=test&amp;age=1</a></p>\n<p>服务端配置如下：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">\"UserProvider\":</span>\n    <span class=\"hljs-string\">//注册中心</span>\n    <span class=\"hljs-attr\">registry:</span> <span class=\"hljs-string\">\"zookeeper\"</span>\n    <span class=\"hljs-string\">//启用REST协议</span>\n    <span class=\"hljs-attr\">protocol :</span> <span class=\"hljs-string\">\"rest\"</span>\n    <span class=\"hljs-string\">//DUBBO的接口名</span>\n    <span class=\"hljs-attr\">interface :</span> <span class=\"hljs-string\">\"com.ikurento.user.UserProvider\"</span>\n    <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">服务接口路径</span>\n    <span class=\"hljs-attr\">rest_path:</span> <span class=\"hljs-string\">\"/UserProvider\"</span>\n    <span class=\"hljs-attr\">methods:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"GetUser\"</span>\n      <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">方法接口路径</span>\n      <span class=\"hljs-attr\">rest_path:</span> <span class=\"hljs-string\">\"/GetUser/{id}\"</span>\n      <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">HTTP方法</span>\n      <span class=\"hljs-attr\">rest_method:</span> <span class=\"hljs-string\">\"GET\"</span>\n      <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">HTTP查询参数</span>\n      <span class=\"hljs-attr\">rest_query_params:</span> <span class=\"hljs-string\">\"1:name,2:age\"</span>\n      <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">HTTP路径参数</span>\n      <span class=\"hljs-attr\">rest_path_params:</span> <span class=\"hljs-string\">\"0:id\"</span>\n      <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">可以提供的内容类型</span>\n      <span class=\"hljs-attr\">rest_produces:</span> <span class=\"hljs-string\">\"application/json;application/xml\"</span>\n      <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">可以接受的客户端参数类型</span>\n      <span class=\"hljs-attr\">rest_consumes:</span> <span class=\"hljs-string\">\"application/json;charset=utf-8,*/*\"</span>\n      <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">HTTP</span> <span class=\"hljs-string\">Body</span>\n      <span class=\"hljs-attr\">rest_body:</span> <span class=\"hljs-number\">-1</span>\n</code></pre>\n<p>在配置文件中我们定义了方法的路径，HTTP 方法等接口参数，这里需要注意的是路径参数和查询参数的配置方式，0:name 的意思是查询参数 name 对应 <code>GetUser</code> 方法的第一个参数，还有 rest_body 配置的数字也是对应这方法的参数，这里没有 body 参数所有就配置了 <code>-1</code>。</p>\n<h2>REST 协议的调用过程</h2>\n<p><img src=\"../../pic/service-governance/implementation-of-rest-protocol-in-dubbo-go-1.jpeg\" alt=\"Dubbogo的Rest协议.001.jpeg\">\n上图展示了用户在 Consumer 端调用  <code>GetUser</code> 方法到 Provdier 端  <code>GetUser</code>  方法被执行的整个过程，在  <code>RestClient</code> 和  <code>RestServer</code> 中分别**实现了  Go  方法参数到  HTTP  请求的转换和 HTTP 请求到  Go  方法的转换，这是最为核心和复杂的部分。**换言之，我们在这里实现了前面提到的 Go 方法和 HTTP 请求的双向映射。</p>\n<p>这里我们可以注意到  <code>RestClient</code> 和 <code>RestServer</code> 是可以用户自行扩展的，下面我将具体介绍一下在 REST 协议中有哪些扩展点设计。</p>\n<h2>REST 协议的扩展点设计</h2>\n<p>基于 dubbo-go 良好的 extension 扩展设计，我们定义了多个扩展点，用户可以自定义功能实现。</p>\n<h3>自定义 HTTP 服务器</h3>\n<p>RestServer 的扩展接口：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> RestServer <span class=\"hljs-keyword\">interface</span> {\n\n    <span class=\"hljs-comment\">// sever启动函数</span>\n\tStart(url common.URL)\n\n    <span class=\"hljs-comment\">// 发布接口</span>\n\tDeploy(restMethodConfig *rest_config.RestMethodConfig, routeFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(request RestServerRequest, response RestServerResponse)</span>)</span>\n\n    <span class=\"hljs-comment\">// 删除接口</span>\n\tUnDeploy(restMethodConfig *rest_config.RestMethodConfig)\n\n    <span class=\"hljs-comment\">// server关闭</span>\n\tDestroy()\n\n}\n</code></pre>\n<p>在 dubbo-go 的 v1.4.0 中默认使用 go-restful 作为 HTTP 服务器，如果用户想用其他 HTTP 容器可以实现上面的接口，并在配置文件中配置使用自己自定义的服务器。</p>\n<p>这个接口中，最核心的方法是 Deploy，在 restMethodConfig 方法参数中有用户配置的接口路径等一系列参数，routeFunc 是 HTTP 接口需要被路由执行的函数。不同的 http 服务器会有不同的 request 和 response ，所以我们定义了 <code>RestServerRequest</code> 接口和 <code>RestServerResponse</code> 接口让用户进行适配。</p>\n<h3>自定义 HTTP 客户端</h3>\n<p>RestClient 的扩展接口：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// RestOptions</span>\n<span class=\"hljs-keyword\">type</span> RestOptions <span class=\"hljs-keyword\">struct</span> {\n\tRequestTimeout time.Duration\n\tConnectTimeout time.Duration\n}\n\n<span class=\"hljs-comment\">// RestClientRequest</span>\n<span class=\"hljs-keyword\">type</span> RestClientRequest <span class=\"hljs-keyword\">struct</span> {\n\tHeader      http.Header\n\tLocation    <span class=\"hljs-keyword\">string</span>\n\tPath        <span class=\"hljs-keyword\">string</span>\n\tMethod      <span class=\"hljs-keyword\">string</span>\n\tPathParams  <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>\n\tQueryParams <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>\n\tBody        <span class=\"hljs-keyword\">interface</span>{}\n}\n\n<span class=\"hljs-comment\">// RestClient user can implement this client interface to send request</span>\n<span class=\"hljs-keyword\">type</span> RestClient <span class=\"hljs-keyword\">interface</span> {\n\tDo(request *RestClientRequest, res <span class=\"hljs-keyword\">interface</span>{}) error\n}\n\n</code></pre>\n<p>最后的请求到客户端时，都会被封装为 <code>RestRequest</code>，用户可以非常简单快速的扩展自己的 Client 端。<code>RestOptions</code> 中有一些客户端的超时配置，在创建自己的客户端时需要根据这些配置初始化客户端。</p>\n<h3>自定义 REST 配置形式</h3>\n<p>前面提到，REST 协议一个很麻烦的地方在于，配置很繁琐很琐碎。Go 不同于 Java，可以通过注解的形式来简化配置。</p>\n<p>所以我们考虑到用户不同的使用习惯和公司的配置风格，提供了这个扩展点。</p>\n<p>ConfigReader 的扩展接口：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> ConfigReader <span class=\"hljs-keyword\">interface</span> {\n\n    <span class=\"hljs-comment\">// Consumer配置读取</span>\n\tReadConsumerConfig(reader *bytes.Buffer) error\n\n    <span class=\"hljs-comment\">// Provider配置读取</span>\n\tReadProviderConfig(reader *bytes.Buffer) error\n\n}\n</code></pre>\n<p><code>ReadConsumerConfig</code> 和 <code>ReadProviderConfig</code> 方法的参数是配置文件的文件流，在实现方法中可以再次解析，也可以使用二次编译或者硬编码方式等其他方式读取配置。这是一个通用的配置读取接口，以后可以用来扩展 REST 配置之外的其他配置，所以需要在方法中调用方法设置配置，如下：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// 设置Rest的消费者配置</span>\nconfig.SetRestConsumerServiceConfigMap(restConsumerServiceConfigMap)\n\n<span class=\"hljs-comment\">// 设置Rest的提供者配置</span>\nconfig.SetRestProviderServiceConfigMap(restProviderServiceConfigMap)\n</code></pre>\n<h2>如何添加 HTTP 过滤器</h2>\n<p>因为不同 HTTP 服务器的过滤器，拦截器或者是 middleware 添加方式都不同，所以我们很难定义一个接口满足所有服务器。因此我们单独为 go-restful 定义了一个添加 filter 的方法，这里我们需要注意的一点是必须在 REST 接口发布前添加 filter。</p>\n<pre><code class=\"language-go\">server_impl.AddGoRestfulServerFilter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(request *restful.Request, response *restful.Response, chain *restful.FilterChain)</span></span> {\n    <span class=\"hljs-comment\">// 鉴权等功能</span>\n    chain.ProcessFilter(request, response)\n})\n\n<span class=\"hljs-comment\">// 启动dubbo服务，发布rest等接口</span>\nconfig.Load()\n</code></pre>\n<h2>展望</h2>\n<p>以上是关于 REST 协议的一些介绍，具体的实现我就不详细讲了，大家可以去参阅源码。</p>\n<p>如果想看具体的 Example，请参考：\n<a href=\"https://github.com/dubbogo/dubbo-samples/tree/master/golang/general/rest\">https://github.com/dubbogo/dubbo-samples/tree/master/golang/general/rest</a></p>\n<p>REST 未来需要支持 HTTPS 协议和基于 open tracing 标准 api 的链路追踪。REST 的配置信息未来也不是 REST 协议独有的，这些配置信息未来可以作为每个 dubbo 接口的元数据，存储到元数据中心，为网关提供 HTTP 协议与 dubbo 协议之间的映射关系。</p>\n<ul>\n<li>\n<p>作者信息：</p>\n<p>蒋超，github id Patrick0308，在 杭州贝安云科技有限公司 任职服务开发工程师。</p>\n</li>\n</ul>\n",
  "link": "/zh-cn/docs/md/service-governance/implementation-of-rest-protocol-in-dubbo-go.html",
  "meta": {
    "title": "dubbo-go 中 REST 协议实现",
    "keywords": "dubbo-go REST协议",
    "description": "介绍dubbo-go 中 REST 协议实现"
  }
}